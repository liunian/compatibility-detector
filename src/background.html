<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Chrome Compatibility Detector</title>
<script>

// Each page's information. This is a tabId to DetectionResult map.
var gDetectionResults = {};

const ICON_PATH = {
  'normal': 'icon_normal.png',
  'ok': 'icon_ok.png',
  'warning': 'icon_warning.png',
  'error': 'icon_error.png'
};

const DETECTION_COMPAT_STATUS_OF_PRIORITY = {
  'normal': 0,
  'ok': 1,
  'warning': 2,
  'error': 3
};

function getDetectionCompatStatus(tabId) {
  var detectionResult = getDetectionResult(tabId);
  if (detectionResult)
    return detectionResult.detectionCompatStatus;
  else
    return 'normal';
}

function setDetectionCompatStatus(tabId, status) {
  var detectionResult = getDetectionResult(tabId);
  if (detectionResult)
    detectionResult.detectionCompatStatus = status;
}

function getDetectionCompatStatusOfPriority(tabId, status) {
  var currentStatus = getDetectionCompatStatus(tabId);
  return DETECTION_COMPAT_STATUS_OF_PRIORITY[currentStatus] >=
      DETECTION_COMPAT_STATUS_OF_PRIORITY[status] ?
      currentStatus : status;
}

function setBrowserAction(status, tabId) {
  status = getDetectionCompatStatusOfPriority(tabId, status);
  setDetectionCompatStatus(tabId, status);
  chrome.browserAction.setIcon({
    path: ICON_PATH[status],
    tabId: tabId
  });
  chrome.browserAction.setTitle({
    title: chrome.i18n.getMessage(status + 'TitleText'),
    tabId: tabId
  });
}

function DetectionResult(tabId) {
  this.tabId = tabId;
  this.problems = {};  // maps reason to Problem object
  this.totalProblems = 0;
  this.totalErrors = 0;
  this.totalWarnings = 0;
  this.detected = false;
  this.annotatedProblems = {};  // maps reason to true
  this.browserActionStatus = 'ok';
  this.detectionCompatStatus = 'normal';
}

DetectionResult.prototype.addProblem = function(problem, reason) {
  this.problems[reason] = problem;
  this.totalProblems++;
  var severity = problem.severity;
  if (severity == 'error') {
    this.totalErrors++;
    if (this.browserActionStatus != severity) {
      this.browserActionStatus = severity;
      setBrowserAction(severity, this.tabId);
    }
  } else {
    this.totalWarnings++;
    if (this.browserActionStatus == 'ok') {
      this.browserActionStatus = severity;
      setBrowserAction(severity, this.tabId);
    }
  }
};

DetectionResult.prototype.getProblem = function(reason) {
  return this.problems[reason];
}

function Problem(severity, description) {
  this.severity = severity;
  this.description = description;
  this.occurrencesNumber = 0;
}

Problem.prototype.setOccurrencesNumber = function(number) {
  this.occurrencesNumber = number;
};

function getDetectionResult(tabId) {
  return gDetectionResults[tabId];
}

function log(message) {
  window.console.log(message);
}

function getPopup() {
  var views = chrome.extension.getViews({type: 'popup'});
  log('views.length=' + views.length);
  if (views.length > 0)
    return views[0];
  return null;
}

/**
 * Add compatibility problem detection result to cache and show in popup page
 * if popup page is opened.
 * @param {Number} tabId
 * @param {Object} issue
 */
function addDetectedProblemToResult(tabId, issue) {
  var reason = issue.reason;
  // First show result if popup page is opened, consider all detection result
  // cache has shown on the popup page this time, so it can't add one problem
  // repeatedly.
  var popup = getPopup();
  if (popup) {
    popup.updateDetectionResult(tabId, reason, issue);
  }

  var detectionResult = getDetectionResult(tabId);
  var problem = detectionResult.getProblem(reason);
  var isNewProblem = false;
  var severity;
  if (!problem) {
    isNewProblem = true;
    severity = issue.severity;
    problem = new Problem(severity, issue.description);
    detectionResult.addProblem(problem, reason);
  }
  problem.setOccurrencesNumber(issue.occurrencesNumber);
  if (popup && isNewProblem) {
    popup.updateSummary(severity);
  }
}

function stopAddingDetectedProblem(tabId, totalProblems) {
  var detectionResult = getDetectionResult(tabId);
  detectionResult.detected = true;

  var popup = getPopup();
  // If totalProblems is 0, show no compatibility problems found infomation.
  if (totalProblems == 0 && popup) {
    popup.showNoProblemResult();
  } else {
    if (popup)
      popup.setDetectionFinishedMessage();
    annotateAllIssues(tabId);
  }
}

function annotateAllIssues(tabId) {
  var detectionResult = getDetectionResult(tabId);
  var reasons = Object.keys(detectionResult.problems);
  reasons.forEach(function(reason) {
    detectionResult.annotatedProblems[reason] = true;
  });
  annotate(reasons);
}

/**
 * Annotate problems on the target node in the page
 * @param {Array} reasons
 */
function annotate(reasons) {
  chrome.tabs.getSelected(null, function(tab) {
    var tabId = tab.id;
    chrome.tabs.sendRequest(tabId, { type: 'AnnotationOff' }, function() {
      if (reasons.length) {
        chrome.tabs.sendRequest(tabId, {
          type: 'AnnotationOn',
          // TODO: rename issusId to reasons
          issusId: reasons
        }, function() {
          var popup = getPopup();
          if (popup) {
            popup.restoreAnnotationCheck();
          }
        });
      }
    });
  });
}

chrome.extension.onRequest.addListener(function(request, sender, sendResponse) {
  var tabId = sender.tab.id;
  switch (request.type) {
    case 'ContentScriptInjected':
      // TODO: do not create DetectionResult here!
      gDetectionResults[tabId] = new DetectionResult(tabId);
      break;
    case 'setStatus':
      setBrowserAction(request.status, tabId);
      break;
    case 'CompatibilityResult':
      addDetectedProblemToResult(tabId, request);
      break;
    case 'EndOfDetection':
      stopAddingDetectedProblem(tabId, request.totalProblems);
      break;
  }
});

// Change status when tab loaded or refreshed.
chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
  if (changeInfo.status == 'loading') {
    delete gDetectionResults[tabId];
    setBrowserAction('normal', tabId);
  }
});

// Delete tab's information when tab closed.
chrome.tabs.onRemoved.addListener(function(tabId) {
  delete gDetectionResults[tabId];
});
</script>
</head>
<body>
</body>
</html>
