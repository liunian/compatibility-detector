<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Chrome Compatibility Detector</title>
</head>
<body>
<script>
/**
 * Change BrowserAction's status.
 * Status: [normal | warning]
 */
const ICON_PATH = {
  'normal': 'icon_normal.png',
  'ok': 'icon_ok.png',
  'warning': 'icon_warning.png',
  'error': 'icon_error.png'
};
function setBrowserAction(status, tabId) {
  chrome.browserAction.setIcon({
    path: ICON_PATH[status],
    tabId: tabId
  });
  chrome.browserAction.setTitle({
    title: chrome.i18n.getMessage(status + 'TitleText'),
    tabId: tabId
  });
}

// Each page's information.
var gDetectionResults = { };

function DetectionResult(tabId) {
  this.tabId = tabId;
  this.problems = {};
  this.totalProblems = 0;
  this.totalErrors = 0;
  this.totalWarnings = 0;
  this.detected = false;
  this.annotatedProblems = {};
  this.browserActionStatus = 'ok';
}

DetectionResult.prototype.addProblem = function(problem, reason) {
  this.problems[reason] = problem;
  this.totalProblems++;
  var severity = problem.severity;
  if (severity == 'error') {
    this.totalErrors++;
    if (this.browserActionStatus != severity) {
      this.browserActionStatus = severity;
      setBrowserAction(severity, this.tabId);
    }
  } else {
    this.totalWarnings++;
    if (this.browserActionStatus == 'ok') {
      this.browserActionStatus = severity;
      setBrowserAction(severity, this.tabId);
    }
  }
};

DetectionResult.prototype.getProblem = function(reason) {
  return this.problems[reason];
}

function Problem(severity, description) {
  this.severity = severity;
  this.description = description;
  this.occurrencesNumber = 0;
}

Problem.prototype.setOccurrencesNumber = function(number) {
  this.occurrencesNumber = number;
};

function getDetectionResult(tabId) {
  var detectionResult = gDetectionResults[tabId];
  if (!detectionResult) {
    detectionResult = new DetectionResult(tabId);
    gDetectionResults[tabId] = detectionResult;
  }
  return detectionResult;
}

function getPopup() {
  return chrome.extension.getViews({type: 'popup'})[0];
}

/**
 * Add compatibility problem detection result to cache and show in popup page
 * if popup page is opened.
 * @param {Number} tabId
 * @param {Object} issue
 */
function addDetectedProblemToResult(tabId, issue) {
  var detectionResult = getDetectionResult(tabId);
  var reason = issue.reason;
  var problem = detectionResult.getProblem(reason);
  var isNewProblem = false;
  var severity;
  if (!problem) {
    isNewProblem = true;
    severity = issue.severity;
    problem = new Problem(severity, issue.description);
    detectionResult.addProblem(problem, reason);
  }
  problem.setOccurrencesNumber(issue.occurrencesNumber);

  // Show result if popup page is opened.
  var popup = getPopup();
  if (popup) {
    popup.updateDetectionResult(reason, problem, true);
    if (isNewProblem)
      popup.updateSummary(severity);
  }
}

function stopAddingDetectionResult(tabId, totalProblems) {
  var detectionResult = getDetectionResult(tabId);
  detectionResult.detected = true;

  var popup = getPopup();
  // If totalProblems is 0, show no compatibility problems found infomation.
  if (totalProblems == 0 && popup) {
    popup.showNoProblemResult();
  } else {
    annotateAllIssues(tabId);
  }
}

function annotateAllIssues(tabId) {
  var detectionResult = getDetectionResult(tabId);
  var problems = Object.keys(detectionResult.problems);
  problems.forEach(function(typeId) {
    detectionResult.annotatedProblems[typeId] = typeId;
  });
  annotate(problems);
}

/**
 * Annotate problems on the target node in the page
 * @param {Array} problems
 */
function annotate(problems) {
  chrome.tabs.getSelected(null, function(tab) {
    var tabId = tab.id;
    chrome.tabs.sendRequest(tabId, { type: 'AnnotationOff' }, function() {
      if (problems.length) {
        chrome.tabs.sendRequest(tabId, {
          type: 'AnnotationOn',
          issusId: problems
        }, function() {
          var popup = getPopup();
          if (popup) {
            popup.restoreAnnotationCheck();
          }
        });
      }
    });
  });
}

chrome.extension.onRequest.addListener(function(request, sender, sendResponse) {
  var tabId = sender.tab.id;
  switch (request.type) {
    case 'setStatus':
      setBrowserAction(request.status, tabId)
      break;
    case 'CompatibilityResult':
      addDetectedProblemToResult(tabId, request);
      break;
    case 'EndOfDetection':
      stopAddingDetectionResult(tabId, request.totalProblems);
      break;
  }
});

// Change status when tab loaded or refreshed.
chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
  if (changeInfo.status == 'loading') {
    delete gDetectionResults[tabId];
    setBrowserAction('normal', tabId);
  }
});

// Delete tab's information when tab closed.
chrome.tabs.onRemoved.addListener(function(tabId) {
  delete gDetectionResults[tabId];
});
</script>
</body>
</html>
